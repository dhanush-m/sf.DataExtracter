"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomationStudio = void 0;
const automationActivities_1 = require("../../sfmc/utils/automationActivities");
const sfmcContextMapping_1 = require("../../sfmc/utils/sfmcContextMapping");
const utils_1 = require("../utils");
const BuildSoapFolderObjects_1 = require("../utils/BuildSoapFolderObjects");
const FormatAutomationAsset_1 = require("../utils/_context/automationStudio/FormatAutomationAsset");
class AutomationStudio {
    constructor(sfmc, contentBuilder, emailStudio) {
        /**
         *
         * @param request.contentType
         * @param request.searchKey
         * @param request.searchTerm
         *
         * ```
         *  {
         *      contentType: '',
         *      searchKey: '',
         *      searchTerm: ''
         *  }
         * ```
         *
         * Output
         * ```
         * [{
         *      Name: string;
         *      ID: number;
         *      CreatedDate: string;
         *      ModifiedDate: string;
         *      ParentFolder: {
         *          Name: string;
         *          ID: string;
         *      }
         *  }]
         * ```
         */
        this.searchFolders = (request) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sfmc.folder.search(request);
            if (response.OverallStatus !== 'OK') {
                return response.OverallStatus;
            }
            const formattedResponse = (response &&
                response.Results &&
                response.Results.length &&
                response.Results.map((folder) => {
                    return {
                        ID: folder.ID,
                        Name: folder.Name,
                        CreatedDate: folder.CreatedDate,
                        ModifiedDate: folder.ModifiedDate,
                        ParentFolder: {
                            Name: folder.ParentFolder.Name,
                            ID: folder.ParentFolder.ID,
                        },
                    };
                })) ||
                [];
            return formattedResponse;
        });
        /**
         *
         * @param request.searchKey
         * @param request.searchTerm
         *
         * ```
         *  {
         *      searchKey: '',
         *      searchTerm: ''
         *  }
         * ```
         *
         * Output
         * ```
         * [{
         *      ID: number,
         *      Name: string,
         *      AssetType: string,
         *      CreatedDate: string,
         *      ModifiedDate: string,
         *      Category: {
         *          Name: string,
         *          ParentId: number
         *      }
         *  }]
         * ```
         */
        this.searchAssets = (request) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sfmc.automation.searchAutomations(request);
            const formattedResponse = (response &&
                response.Results &&
                response.Results.map((asset) => {
                    return {
                        ObjectId: asset.ObjectID,
                        Name: asset.Name,
                        Description: asset.Description,
                        Status: asset.Status,
                        CreatedDate: asset.CreatedDate,
                        ModifiedDate: asset.ModifiedDate,
                        IsActive: asset.IsActive,
                    };
                })) ||
                [];
            return formattedResponse;
        });
        /**
         *
         * @param request.searchKey
         * @param request.searchTerm
         *
         * ```
         *  {
         *      searchKey: '',
         *      searchTerm: ''
         *  }
         * ```
         *
         * Output
         * ```
         * [{
         *      ID: number,
         *      Name: string,
         *      AssetType: string,
         *      CreatedDate: string,
         *      ModifiedDate: string,
         *      Category: {
         *          Name: string,
         *          ParentId: number
         *      }
         *  }]
         * ```
         */
        this.gatherAssetsByCategoryId = (request) => __awaiter(this, void 0, void 0, function* () {
            try {
                const folderResponse = yield this.sfmc.folder.getFoldersFromMiddle(request);
                const buildFolderPaths = yield (0, BuildSoapFolderObjects_1.buildFolderPathsSoap)(folderResponse.full);
                const formattedFolders = buildFolderPaths.folders.map((folder) => {
                    return {
                        id: folder.ID,
                        name: folder.Name,
                        parentId: folder.ParentFolder.ID,
                        folderPath: folder.FolderPath,
                    };
                });
                const isolateFolderIds = folderResponse &&
                    folderResponse.full &&
                    folderResponse.full.length &&
                    folderResponse.full
                        .map((folder) => folder.Name !== 'my automations' && folder.ID)
                        .filter(Boolean);
                const collectAutomationKeys = yield this.sfmc.automation.getAssetsByFolderArray(isolateFolderIds);
                const isolateAutomationKeys = collectAutomationKeys &&
                    collectAutomationKeys.length &&
                    collectAutomationKeys.map((asset) => asset.id);
                const assetResponse = isolateAutomationKeys &&
                    isolateAutomationKeys.length &&
                    (yield this.sfmc.automation.getAutomationsByKey(isolateAutomationKeys));
                if (assetResponse &&
                    assetResponse.response &&
                    assetResponse.response.status &&
                    !assetResponse.response.status.test(/^2/)) {
                    throw new Error(assetResponse.response.statusText);
                }
                const formattedAssetResponse = assetResponse &&
                    assetResponse.length &&
                    buildFolderPaths &&
                    (yield (0, FormatAutomationAsset_1.formatAutomation)(assetResponse, buildFolderPaths.folders));
                const formattedAutomationDefinitions = yield this.gatherAutomationActivityDefinitions(formattedAssetResponse);
                const formattedAutomationDependencies = formattedAutomationDefinitions &&
                    (yield this.gatherAutomationActivityDependencies(formattedAutomationDefinitions));
                return {
                    folders: formattedFolders || [],
                    assets: formattedAssetResponse || [],
                    formattedAutomationDefinitions,
                    formattedAutomationDependencies,
                };
            }
            catch (err) {
                return err.message;
            }
        });
        /**
         *
         * @param objectId
         */
        this.gatherAssetById = (objectId) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!objectId) {
                    throw new Error('objectId is required');
                }
                const assetResponse = yield this.sfmc.automation.getAutomationByKey(objectId);
                if (assetResponse &&
                    assetResponse.response &&
                    assetResponse.response.status &&
                    !assetResponse.response.status.test(/^2/)) {
                    throw new Error(assetResponse.response.statusText);
                }
                const categoryId = assetResponse && assetResponse.categoryId;
                const folderResponse = yield this.sfmc.folder.getParentFoldersRecursive({
                    contentType: 'automations',
                    categoryId,
                });
                const simplifiedFolderResponse = (folderResponse.results &&
                    Array.isArray(folderResponse.results) &&
                    folderResponse.results.map((folder) => {
                        return {
                            ID: folder.ID,
                            Name: folder.Name,
                            ContentType: folder.ContentType,
                            ParentFolder: {
                                Name: folder.ParentFolder.Name ||
                                    'my automations',
                                ID: folder.ParentFolder.ID,
                            },
                        };
                    })) ||
                    [];
                const buildFolderPaths = yield (0, BuildSoapFolderObjects_1.buildFolderPathsSoap)(simplifiedFolderResponse);
                const formattedFolders = buildFolderPaths.folders.map((folder) => {
                    return {
                        id: folder.ID,
                        name: folder.Name,
                        parentId: folder.ParentFolder.ID,
                        folderPath: folder.FolderPath,
                    };
                });
                const formattedAssetResponse = assetResponse &&
                    buildFolderPaths &&
                    (yield (0, FormatAutomationAsset_1.formatAutomation)(assetResponse, buildFolderPaths.folders));
                const formattedAutomationDefinitions = yield this.gatherAutomationActivityDefinitions(formattedAssetResponse);
                const formattedAutomationDependencies = formattedAutomationDefinitions &&
                    (yield this.gatherAutomationActivityDependencies(formattedAutomationDefinitions));
                return {
                    folders: formattedFolders || [],
                    assets: formattedAssetResponse || [],
                    formattedAutomationDefinitions,
                    formattedAutomationDependencies,
                };
            }
            catch (err) {
                return err.message;
            }
        });
        /**
         *
         * @param automations
         */
        this.gatherAutomationActivityDefinitions = (automations) => __awaiter(this, void 0, void 0, function* () {
            try {
                const automationDefinitionOutput = [];
                if (Array.isArray(automations)) {
                    for (const a in automations) {
                        const automation = automations[a];
                        const automationActivityDefinitions = yield this.sfmc.automation.getAutomationActivities(automation);
                        automationActivityDefinitions &&
                            automationActivityDefinitions.forEach((definition) => {
                                definition.bldrId = (0, utils_1.guid)();
                                automationDefinitionOutput.push(definition);
                            });
                    }
                }
                else {
                    const automationActivityDefinitions = yield this.sfmc.automation.getAutomationActivities(automations);
                    automationActivityDefinitions &&
                        automationActivityDefinitions.forEach((definition) => {
                            definition.bldrId = (0, utils_1.guid)();
                            automationDefinitionOutput.push(definition);
                        });
                }
                const finalOutput = [];
                const finalOutputLog = [];
                for (const a in automationDefinitionOutput) {
                    const asset = automationDefinitionOutput[a];
                    const objectMapping = yield (0, automationActivities_1.MappingByActivityType)(asset.assetType.name);
                    const objectIdKey = objectMapping && objectMapping.objectIdKey;
                    if (objectIdKey &&
                        !finalOutputLog.includes(asset[objectIdKey])) {
                        finalOutputLog.push(asset[objectIdKey]);
                        finalOutput.push(asset);
                    }
                }
                return finalOutput;
            }
            catch (err) {
                console.error(err);
            }
        });
        /**
         *
         * @param automationDefinitions
         */
        this.gatherAutomationActivityDependencies = (automationDefinitions) => __awaiter(this, void 0, void 0, function* () {
            try {
                const formattedAutomationDependencies = {
                    automationStudio: [],
                    contentBuilder: [],
                    emailStudio: [],
                };
                for (const a in automationDefinitions) {
                    const definition = automationDefinitions[a];
                    const assetType = definition &&
                        typeof definition === 'object' &&
                        definition.assetType;
                    const assetTypeName = assetType && assetType.name;
                    let assetIdKey;
                    let DECustomerKey;
                    let findDECustomerKey;
                    let dataExtensionAssetResponse;
                    let dataExtensionAssetResponseStatus;
                    let customerKeyArr = [];
                    switch (assetTypeName) {
                        case 'userinitiatedsend':
                            const legacyId = definition &&
                                definition.Email &&
                                definition.Email.ID;
                            const emailAssetResponse = legacyId &&
                                (yield this.contentBuilder.gatherAssetById(legacyId, true));
                            emailAssetResponse &&
                                emailAssetResponse.assets &&
                                formattedAutomationDependencies &&
                                typeof formattedAutomationDependencies ===
                                    'object' &&
                                Object.prototype.hasOwnProperty.call(formattedAutomationDependencies, 'contentBuilder') &&
                                (formattedAutomationDependencies === null || formattedAutomationDependencies === void 0 ? void 0 : formattedAutomationDependencies.contentBuilder) &&
                                Array.isArray(formattedAutomationDependencies.contentBuilder) &&
                                formattedAutomationDependencies.contentBuilder.push(emailAssetResponse);
                        case 'dataextractactivity':
                        case 'importactivity':
                        case 'userinitiatedsend':
                        case 'queryactivity':
                            if (assetTypeName === 'dataextractactivity') {
                                findDECustomerKey = definition.dataFields.find((dataField) => dataField.name === 'DECustomerKey');
                                findDECustomerKey &&
                                    findDECustomerKey.value &&
                                    customerKeyArr.push(findDECustomerKey.value);
                            }
                            else if (assetTypeName === 'importactivity') {
                                findDECustomerKey =
                                    yield this.emailStudio.searchDataExtensions({
                                        searchKey: 'ObjectID',
                                        searchTerm: definition.destinationObjectId,
                                    });
                                findDECustomerKey &&
                                    Array.isArray(findDECustomerKey) &&
                                    findDECustomerKey.length === 1 &&
                                    findDECustomerKey[0].CustomerKey &&
                                    customerKeyArr.push(findDECustomerKey[0].CustomerKey);
                            }
                            else if (assetTypeName === 'queryactivity') {
                                definition &&
                                    definition.targetKey &&
                                    customerKeyArr.push(definition.targetKey);
                            }
                            else if (assetTypeName === 'userinitiatedsend') {
                                const sendDefinitionList = (definition && definition.SendDefinitionList) ||
                                    [];
                                const sendDefinitionListIDs = sendDefinitionList &&
                                    sendDefinitionList.length &&
                                    (yield Promise.all(sendDefinitionList.map((sendDefinitionObject) => __awaiter(this, void 0, void 0, function* () {
                                        findDECustomerKey =
                                            yield this.emailStudio.searchDataExtensions({
                                                searchKey: 'ObjectID',
                                                searchTerm: sendDefinitionObject.CustomObjectID,
                                            });
                                        return (findDECustomerKey &&
                                            Array.isArray(findDECustomerKey) &&
                                            findDECustomerKey.length ===
                                                1 &&
                                            findDECustomerKey[0].CustomerKey);
                                    }))));
                                sendDefinitionListIDs &&
                                    sendDefinitionListIDs.length &&
                                    customerKeyArr.push(...sendDefinitionListIDs);
                            }
                            for (const d in customerKeyArr) {
                                const customerKey = customerKeyArr[d];
                                let dataExtensionAssetResponse = yield this.emailStudio.gatherAssetById(customerKey, true);
                                dataExtensionAssetResponseStatus =
                                    dataExtensionAssetResponse &&
                                        dataExtensionAssetResponse.status;
                                if (dataExtensionAssetResponseStatus &&
                                    dataExtensionAssetResponseStatus === 'error') {
                                    dataExtensionAssetResponse =
                                        yield this.emailStudio.gatherAssetById(customerKey, true, true);
                                }
                                formattedAutomationDependencies.emailStudio.push(dataExtensionAssetResponse);
                            }
                            break;
                    }
                }
                const finalOutput = {};
                for (const a in formattedAutomationDependencies) {
                    const context = a;
                    const contextDependencies = formattedAutomationDependencies[context];
                    let assetIdKey = ['contentBuilder'].includes(context)
                        ? 'id'
                        : ['emailStudio'].includes(context)
                            ? 'objectId'
                            : null;
                    const folders = contextDependencies
                        .map((dep) => dep.folders)
                        .filter(Boolean);
                    const assets = contextDependencies
                        .map((dep) => dep.assets)
                        .filter(Boolean);
                    const uniqueAssets = assetIdKey &&
                        (yield (0, utils_1.uniqueArrayByKey)(assets.flat(), assetIdKey));
                    const uniqueFolders = yield (0, utils_1.uniqueArrayByKey)(folders.flat(), 'id');
                    finalOutput[context] = {
                        folders: uniqueFolders || [],
                        assets: uniqueAssets || [],
                    };
                }
                return finalOutput || {};
            }
            catch (err) {
                return err;
            }
        });
        /**
         * Method to search Automation Studio Activity Endpoint
         *
         * @param {string} searchActivity Endpoint property to search
         * @param {string} searchTerm of asset to search for
         */
        this.searchActivity = (searchActivity, searchTerm) => __awaiter(this, void 0, void 0, function* () {
            try {
                let activity = '';
                switch (searchActivity) {
                    case 'ssjs':
                        activity = 'scripts';
                        break;
                    case 'sql':
                        activity = 'queries';
                        break;
                }
                const resp = yield this.sfmc.automation.searchActivity(activity, searchTerm);
                if (Object.prototype.hasOwnProperty.call(resp, 'items') &&
                    resp.items.length === 0) {
                    throw new Error(`No Search Items Returned for ${searchTerm}`);
                }
                return ((resp &&
                    resp.items &&
                    resp.items.length &&
                    resp.items.map((result) => {
                        let objectKey = '';
                        switch (searchActivity) {
                            case 'ssjs':
                                objectKey = 'ssjsActivityId';
                                break;
                            case 'sql':
                                objectKey = 'queryDefinitionId';
                                break;
                        }
                        return {
                            Name: result.name,
                            [objectKey]: result[objectKey],
                            CategoryID: result.categoryId,
                            ModifiedDate: result.modifiedDate,
                        };
                    })) ||
                    []);
            }
            catch (err) {
                return err;
            }
        });
        this.gatherAutomationDefinitionsByCategoryId = (request, removeRoot = false) => __awaiter(this, void 0, void 0, function* () {
            const folderResponse = yield this.sfmc.folder.getFoldersFromMiddle(request);
            const buildFolderPaths = yield (0, BuildSoapFolderObjects_1.buildFolderPathsSoap)(folderResponse);
            const rootFolderObj = sfmcContextMapping_1.sfmc_context_mapping.find((ctxFolder) => ctxFolder.contentType === request.contentType);
            const rootFolder = rootFolderObj && rootFolderObj.name;
            const definitionApi = rootFolderObj && rootFolderObj.api;
            const rootFolderResponse = yield this.sfmc.folder.search({
                contentType: request.contentType,
                searchKey: 'Name',
                searchTerm: rootFolder,
            });
            const rootFolderID = (rootFolderResponse.OverallStatus === 'OK' &&
                rootFolderResponse.Results &&
                rootFolderResponse.Results[0] &&
                rootFolderResponse.Results[0].ID) ||
                null;
            const isolateFolderIds = rootFolderID && rootFolderID !== request.categoryId
                ? (buildFolderPaths &&
                    buildFolderPaths.folders &&
                    buildFolderPaths.folders.length &&
                    buildFolderPaths.folders
                        .map((folder) => rootFolderID !== folder.ID && folder.ID)
                        .filter(Boolean)) ||
                    []
                : (buildFolderPaths &&
                    buildFolderPaths.folders &&
                    buildFolderPaths.folders.length &&
                    buildFolderPaths.folders.map((folder) => folder.ID)) ||
                    [];
            const definitionReturn = [];
            for (const i in isolateFolderIds) {
                const definitionRequest = yield this.sfmc.automation.searchActivityByCategoryId({
                    searchActivity: definitionApi,
                    categoryId: isolateFolderIds[i],
                });
                definitionReturn.push(...definitionRequest.items);
            }
            return {
                assets: definitionReturn || [],
                folders: buildFolderPaths.folders,
            };
        });
        this.gatherAutomationDefinitionsById = (request) => __awaiter(this, void 0, void 0, function* () {
            const rootFolderObj = sfmcContextMapping_1.sfmc_context_mapping.find((ctxFolder) => ctxFolder.contentType === request.contentType);
            const rootFolder = rootFolderObj && rootFolderObj.name;
            const definitionApi = rootFolderObj && rootFolderObj.api;
            const definitionRequest = yield this.sfmc.automation.getAutomationActivity({
                activityType: definitionApi,
                activityObjectId: request.assetId,
            });
            const folderResponse = definitionRequest &&
                (yield this.sfmc.folder.getFoldersFromMiddle({
                    contentType: request.contentType,
                    categoryId: definitionRequest.categoryId,
                }));
            const buildFolderPaths = yield (0, BuildSoapFolderObjects_1.buildFolderPathsSoap)(folderResponse.full);
            return {
                assets: Array.isArray(definitionRequest)
                    ? definitionRequest
                    : new Array(definitionRequest) || [],
                folders: buildFolderPaths.folders,
            };
        });
        this.sfmc = sfmc;
        this.contentBuilder = contentBuilder;
        this.emailStudio = emailStudio;
    }
}
exports.AutomationStudio = AutomationStudio;
