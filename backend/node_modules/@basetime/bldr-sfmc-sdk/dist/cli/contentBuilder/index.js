"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentBuilder = void 0;
const BuildSoapFolderObjects_1 = require("../utils/BuildSoapFolderObjects");
const FormatContentBuilderAsset_1 = require("../utils/_context/contentBuilder/FormatContentBuilderAsset");
const GetContentBuilderAssetContent_1 = require("../utils/_context/contentBuilder/GetContentBuilderAssetContent");
const GetContentBuilderAssetDependencies_1 = require("../utils/_context/contentBuilder/GetContentBuilderAssetDependencies");
const PackageReference_1 = require("../utils/_context/contentBuilder/PackageReference");
class ContentBuilder {
    constructor(sfmc) {
        /**
         *
         * @param request.contentType
         * @param request.searchKey
         * @param request.searchTerm
         *
         * ```
         *  {
         *      contentType: '',
         *      searchKey: '',
         *      searchTerm: ''
         *  }
         * ```
         *
         * Output
         * ```
         * [{
         *      Name: string;
         *      ID: number;
         *      CreatedDate: string;
         *      ModifiedDate: string;
         *      ParentFolder: {
         *          Name: string;
         *          ID: string;
         *      }
         *  }]
         * ```
         */
        this.searchFolders = (request) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sfmc.folder.search(request);
            if (response.OverallStatus !== 'OK') {
                return response.OverallStatus;
            }
            const formattedResponse = (response &&
                response.Results &&
                response.Results.length &&
                response.Results.map((folder) => {
                    return {
                        ID: folder.ID,
                        Name: folder.Name,
                        CreatedDate: folder.CreatedDate,
                        ModifiedDate: folder.ModifiedDate,
                        ParentFolder: {
                            Name: folder.ParentFolder.Name,
                            ID: folder.ParentFolder.ID,
                        },
                    };
                })) ||
                [];
            return formattedResponse;
        });
        /**
         *
         * @param request.searchKey
         * @param request.searchTerm
         *
         * ```
         *  {
         *      searchKey: '',
         *      searchTerm: ''
         *  }
         * ```
         *
         * Output
         * ```
         * [{
         *      ID: number,
         *      Name: string,
         *      AssetType: string,
         *      CreatedDate: string,
         *      ModifiedDate: string,
         *      Category: {
         *          Name: string,
         *          ParentId: number
         *      }
         *  }]
         * ```
         */
        this.searchAssets = (request) => __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.sfmc.asset.searchAssets(request);
                const formattedResponse = (response &&
                    response.items &&
                    response.items.length &&
                    response.items.map((asset) => {
                        var _a, _b, _c;
                        let assetOutput = {
                            ID: asset.id,
                            Name: asset.name,
                            AssetType: asset.assetType.name,
                            CreatedDate: asset.createdDate,
                            ModifiedDate: asset.modifiedDate,
                            Category: {
                                Name: asset.category.name,
                                ParentId: asset.category.parentId,
                            },
                        };
                        if (((_a = asset === null || asset === void 0 ? void 0 : asset.assetType) === null || _a === void 0 ? void 0 : _a.displayName) === 'Image') {
                            assetOutput.PublishedURL =
                                (_b = asset === null || asset === void 0 ? void 0 : asset.fileProperties) === null || _b === void 0 ? void 0 : _b.publishedURL;
                            assetOutput.ImageType =
                                (_c = asset === null || asset === void 0 ? void 0 : asset.fileProperties) === null || _c === void 0 ? void 0 : _c.extension;
                        }
                        if (Object.prototype.hasOwnProperty.call(asset, 'sharingProperties')) {
                            assetOutput.sharingProperties =
                                asset.sharingProperties;
                        }
                        return assetOutput;
                    })) ||
                    [];
                return formattedResponse;
            }
            catch (err) {
                return err;
            }
        });
        /**
         *
         * @param request.searchKey
         * @param request.searchTerm
         *
         * ```
         *  {
         *      searchKey: '',
         *      searchTerm: ''
         *  }
         * ```
         *
         * Output
         * ```
         * [{
         *      ID: number,
         *      Name: string,
         *      AssetType: string,
         *      CreatedDate: string,
         *      ModifiedDate: string,
         *      Category: {
         *          Name: string,
         *          ParentId: number
         *      }
         *  }]
         * ```
         */
        this.gatherAssetsByCategoryId = (request, shared = false) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!request.contentType) {
                    throw new Error('contentType required');
                }
                if (!request.categoryId) {
                    throw new Error('categoryId required');
                }
                const rootFolderName = shared
                    ? 'Shared Content'
                    : 'Content Builder';
                const folderResponse = yield this.sfmc.folder.getFoldersFromMiddle({
                    contentType: shared ? 'asset-shared' : 'asset',
                    categoryId: request.categoryId,
                });
                const isolateFolderIds = folderResponse &&
                    folderResponse.full &&
                    folderResponse.full.length &&
                    folderResponse.full
                        .map((folder) => folder.Name !== rootFolderName && folder.ID)
                        .filter(Boolean);
                const assetsAndFoldersRequest = yield Promise.all([
                    (0, BuildSoapFolderObjects_1.buildFolderPathsSoap)(folderResponse.full),
                    this.sfmc.asset.getAssetsByFolderArray(isolateFolderIds),
                ]);
                const buildFolderPaths = (assetsAndFoldersRequest && assetsAndFoldersRequest[0]) || [];
                const assetResponse = (assetsAndFoldersRequest && assetsAndFoldersRequest[1]) || [];
                if (assetResponse &&
                    assetResponse.response &&
                    assetResponse.response.status &&
                    !/^2/.test(assetResponse.response.status.toString())) {
                    if (assetResponse.response &&
                        assetResponse.response.data &&
                        assetResponse.response.data.message) {
                        throw new Error(assetResponse.response.data.message);
                    }
                    else {
                        throw new Error('There is an issue with the request. Check privileges and try again.');
                    }
                }
                const formatResponses = yield Promise.all([
                    (0, FormatContentBuilderAsset_1.formatContentBuilderAssets)(assetResponse.items, buildFolderPaths.folders),
                    buildFolderPaths.folders.map((folder) => {
                        return {
                            id: folder.ID,
                            name: folder.Name,
                            parentId: folder.ParentFolder.ID,
                            folderPath: folder.FolderPath,
                        };
                    }),
                ]);
                const formattedAssetResponse = (formatResponses && formatResponses[0]) || [];
                const formattedFolders = (formatResponses && formatResponses[1]) || [];
                return {
                    folders: formattedFolders || [],
                    assets: formattedAssetResponse || [],
                    rawAssets: assetResponse.items || [],
                };
            }
            catch (err) {
                return {
                    status: 'error',
                    statusMessage: err.message,
                };
            }
        });
        /**
         *
         * @param assetId
         */
        this.gatherAssetById = (assetId, legacy = false, shared = false) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!assetId) {
                    throw new Error('assetId is required');
                }
                // Accounts for LegacyIds and Content Builder AssetIds
                let assetResponse = (legacy &&
                    (yield this.sfmc.asset.getAssetByLegacyId(assetId))) ||
                    (yield this.sfmc.asset.getByAssetId(assetId));
                assetResponse =
                    (legacy &&
                        assetResponse &&
                        assetResponse.items &&
                        assetResponse.items.length &&
                        assetResponse.items[0]) ||
                        assetResponse;
                if (assetResponse && !assetResponse.id) {
                    throw new Error(assetResponse);
                }
                const categoryId = assetResponse &&
                    assetResponse.category &&
                    assetResponse.category.id;
                const folderResponse = yield this.sfmc.folder.getFoldersFromMiddle({
                    contentType: shared ? 'asset-shared' : 'asset',
                    categoryId,
                });
                const buildFolderPaths = yield (0, BuildSoapFolderObjects_1.buildFolderPathsSoap)(folderResponse.full);
                let formattedAssetResponse = (assetResponse &&
                    buildFolderPaths &&
                    buildFolderPaths.folders &&
                    (yield (0, FormatContentBuilderAsset_1.formatContentBuilderAssets)(assetResponse, buildFolderPaths.folders))) ||
                    [];
                const formattedFolders = (buildFolderPaths.folders &&
                    buildFolderPaths.folders.length &&
                    buildFolderPaths.folders.map((folder) => {
                        return {
                            id: folder.ID,
                            name: folder.Name,
                            parentId: folder.ParentFolder.ID,
                            folderPath: folder.FolderPath,
                        };
                    })) ||
                    [];
                return {
                    folders: formattedFolders || [],
                    assets: formattedAssetResponse || [],
                };
            }
            catch (err) {
                return err;
            }
        });
        /**
         *
         * @param asset
         * @param content
         * @returns
         */
        this.updateContentBuilderAssetContent = (asset, content) => {
            const assetType = (asset.assetType && asset.assetType.name) || null;
            switch (assetType) {
                case 'webpage':
                case 'htmlemail':
                    asset.views.html.content = content;
                    break;
                case 'codesnippetblock':
                case 'htmlblock':
                case 'jscoderesource':
                    asset.content = content;
                    break;
                case 'textonlyemail':
                    asset.views.text.content = content;
                    break;
                default:
            }
            return asset;
        };
        this.setContentBuilderPackageAssets = (packageOut, contextAssets) => __awaiter(this, void 0, void 0, function* () {
            packageOut['contentBuilder'] = {};
            return ((packageOut['contentBuilder']['assets'] =
                contextAssets &&
                    contextAssets.length &&
                    contextAssets.map((asset) => {
                        return {
                            id: asset.id,
                            bldrId: asset.bldrId,
                            name: asset.name,
                            assetType: asset.assetType,
                            category: {
                                folderPath: (asset.category && asset.category.folderPath) ||
                                    asset.folderPath,
                            },
                            content: (0, GetContentBuilderAssetContent_1.getContentBuilderAssetContent)(asset),
                        };
                    })) || []);
        });
        /**
         *
         * @param packageOut
         */
        this.setContentBuilderDependenciesFromPackage = (packageOut) => __awaiter(this, void 0, void 0, function* () {
            try {
                const newDependencies = {};
                for (const a in packageOut['contentBuilder']['assets']) {
                    let asset = packageOut['contentBuilder']['assets'][a];
                    let content = yield (0, GetContentBuilderAssetContent_1.getContentBuilderAssetContent)(asset);
                    asset.dependencies = [];
                    for (const p in PackageReference_1.contentBuilderPackageReference) {
                        const reference = PackageReference_1.contentBuilderPackageReference[p];
                        let regex = `${reference}\\(['"](?<value>.+)['"]\\)`;
                        let ampscriptRegex = new RegExp(regex, 'g');
                        let matches = content && content.matchAll(ampscriptRegex);
                        for (const match of matches) {
                            const groups = Object.assign(match.groups, {});
                            let matchedValue = groups.value;
                            matchedValue = matchedValue.replace(/['"]/gm, '');
                            let dependency = yield (0, GetContentBuilderAssetDependencies_1.getAssetDependency)(this.sfmc, reference, matchedValue, asset, packageOut);
                            matchedValue = dependency.matchedValue || matchedValue;
                            let dependencyReference = {
                                bldrId: dependency.bldrId,
                                context: dependency.context,
                                reference,
                            };
                            if (dependency && dependency.exists) {
                                asset.content = yield (0, GetContentBuilderAssetDependencies_1.setUpdatedPackageAssetContent)(dependencyReference, matchedValue, content);
                                asset.dependencies.push(dependencyReference);
                                content = asset.content;
                                // remove matched value from dependency object
                                delete dependency.matchedValue;
                            }
                            else {
                                let dependencyContext = dependency.context;
                                asset.dependencies.push({
                                    bldrId: dependency.bldrId,
                                    context: dependency.context,
                                    reference,
                                });
                                asset.content = yield (0, GetContentBuilderAssetDependencies_1.setUpdatedPackageAssetContent)(dependencyReference, matchedValue, content);
                                content = asset.content;
                                newDependencies[dependencyContext] =
                                    newDependencies[dependencyContext] || {
                                        assets: [],
                                    };
                                packageOut[dependencyContext] = packageOut[dependencyContext] || {
                                    assets: [],
                                };
                                newDependencies[dependencyContext]['assets'].push(dependency.payload);
                                packageOut[dependencyContext]['assets'].push(dependency.payload);
                            }
                        }
                    }
                }
                return {
                    newDependencies,
                    packageOut,
                };
            }
            catch (err) {
                console.log(err);
                console.log('Some dependencies in package do not exist');
            }
        });
        this.sfmc = sfmc;
    }
}
exports.ContentBuilder = ContentBuilder;
