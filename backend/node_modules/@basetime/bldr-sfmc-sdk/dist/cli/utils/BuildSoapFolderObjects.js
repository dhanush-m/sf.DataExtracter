"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFolderPathsSoap = void 0;
const _1 = require(".");
const buildFolderPathsSoap = (folderResponse) => __awaiter(void 0, void 0, void 0, function* () {
    const simplifiedFolders = yield simplifiedFolderResponse(folderResponse);
    const parentFolders = [
        'Content Builder',
        'Shared Content',
        'my automations',
        'Data Extensions',
        'Shared Data Extensions',
        'Query',
        'Scripts',
    ];
    let folders = yield (0, _1.uniqueArrayByKey)(simplifiedFolders, 'ID');
    folders = folders.sort((a, b) => a.ID - b.ID);
    const foldersOut = [];
    const compiledFolderPaths = [];
    let path = '';
    // Get parent folder and get folder ID
    let parentFolderObject = folders.find((folder) => !!parentFolders.includes(folder.Name));
    if (!parentFolderObject) {
        throw new Error('Unable to find parent folder');
    }
    const rootFolder = parentFolderObject && parentFolderObject.Name;
    // Add Foot Folder to Path String
    path += parentFolderObject && parentFolderObject.Name;
    // Add FolderPath to folder object
    parentFolderObject.FolderPath = path;
    // Add Folder Object to Output Array
    foldersOut.push(parentFolderObject);
    // Add Folder Path CompiledFolderPaths Array
    compiledFolderPaths.push(path);
    // Remove processed Object from Original Array
    folders.splice(folders.findIndex((folder) => !!parentFolders.includes(rootFolder)), 1);
    // Reset Path String
    path = '';
    do {
        for (const f in folders) {
            const folder = folders[f];
            const parentFolder = folder.ParentFolder.Name || parentFolderObject.Name;
            let parentIsRootFolder = parentFolder === rootFolder ? true : false;
            if (parentIsRootFolder) {
                // Add Foot Folder to Path String
                path += folder && folder.Name && `${rootFolder}/${folder.Name}`;
                // Add FolderPath to folder object
                folder.FolderPath = path;
                // Add Folder Object to Output Array
                foldersOut.push(folder);
                // Add Folder Path CompiledFolderPaths Array
                compiledFolderPaths.push(path);
                // Remove processed Object from Original Array
                folders.splice(folders.findIndex((orgFolder) => orgFolder.ID === folder.ID), 1);
                // Reset Path String
                path = '';
            }
            else {
                let parentId = folder.ParentFolder.ID;
                let compiledParentFolder = foldersOut.find((compiledFolder) => compiledFolder.ID === parentId);
                if (compiledParentFolder) {
                    // Add Foot Folder to Path String
                    path +=
                        folder &&
                            folder.Name &&
                            `${compiledParentFolder.FolderPath}/${folder.Name}`;
                    // Add FolderPath to folder object
                    folder.FolderPath = path;
                    // Add Folder Object to Output Array
                    foldersOut.push(folder);
                    // Add Folder Path CompiledFolderPaths Array
                    compiledFolderPaths.push(path);
                    // Remove processed Object from Original Array
                    folders.splice(folders.findIndex((orgFolder) => Number(orgFolder.ID) === Number(folder.ID)), 1);
                    // Reset Path String
                    path = '';
                }
            }
        }
    } while (folders.length);
    return {
        folders: foldersOut,
        folderPaths: compiledFolderPaths,
    };
});
exports.buildFolderPathsSoap = buildFolderPathsSoap;
const simplifiedFolderResponse = (folderResponse) => {
    return ((folderResponse &&
        folderResponse.length &&
        folderResponse.map((folder) => {
            return {
                ID: folder.ID,
                Name: folder.Name,
                ContentType: folder.ContentType,
                ParentFolder: {
                    Name: folder.ParentFolder.Name,
                    ID: folder.ParentFolder.ID,
                },
            };
        })) ||
        []);
};
