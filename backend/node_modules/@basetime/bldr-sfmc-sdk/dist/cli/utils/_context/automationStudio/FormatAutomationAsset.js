"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAutomation = void 0;
const __1 = require("../..");
/**
 * Format raw API response to be slimmed down object
 *
 * @param asset
 * @param folders
 * @returns
 */
const setAssetPostObject = (asset, folders) => {
    // Generate new bldrId for asset
    const bldrId = (0, __1.guid)();
    // Find Compiled Folder Path from Folders Array
    const findAssetsFolderObject = folders.find(({ ID }) => ID === asset.categoryId);
    // Set Assets folderPath or initiate as blank
    const folderPath = findAssetsFolderObject
        ? findAssetsFolderObject.FolderPath
        : '';
    const folderName = findAssetsFolderObject
        ? findAssetsFolderObject.Name
        : '';
    // Create JSON structure for new asset post
    let post = {
        id: asset.id,
        bldrId,
        name: asset.name,
        key: asset.key,
        categoryId: asset.categoryId,
        category: {
            folderPath,
            name: folderName,
        },
        description: asset.description,
        typeId: asset.typeId,
        type: asset.type,
        statusId: asset.statusId,
        status: asset.status,
        steps: asset.steps,
        assetType: {
            name: 'automation',
            folder: 'Automation Studio/my automations',
        },
    };
    if (asset.schedule && asset.schedule.scheduleStatus) {
        post.schedule = {
            scheduleStatus: asset.schedule.scheduleStatus,
        };
    }
    return post;
};
/**
 * Method to format API response from SFMC into minimum required POST/PUT JSON objects
 * Updates Category object with full folder paths
 * Gathers additional data for Image assets
 *
 * @param {object} results from API Request
 * @param {object} folderPaths category object
 * @returns {object} Array of formatted asset payloads
 */
const formatAutomation = (results, folders) => __awaiter(void 0, void 0, void 0, function* () {
    const formattedAssets = [];
    if (Array.isArray(results) && results.length !== 0) {
        for (const r in results) {
            const asset = results[r];
            const post = setAssetPostObject(asset, folders);
            formattedAssets.push(post);
        }
    }
    else {
        const post = setAssetPostObject(results, folders);
        formattedAssets.push(post);
    }
    return formattedAssets;
});
exports.formatAutomation = formatAutomation;
