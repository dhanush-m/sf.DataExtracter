"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpdatedPackageAssetContent = exports.getAssetDependency = void 0;
const __1 = require("../..");
/**
 * Gather dependency when Package Reference RegEx
 * @param reference
 * @param matchedValue
 * @param asset
 * @param assets
 * @returns
 */
const getAssetDependency = (client, reference, matchedValue, asset, packageOut) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    let resp = {
        exists: false,
        matchedValue,
        reference,
        context: '',
        payload: {},
        dependencies: [],
    };
    // Generate new bldrId for asset
    let assetExists = false;
    let contentBlockPathArray;
    let contentBlockName;
    let contentBlockFolder;
    let bldrId;
    switch (reference) {
        case 'Lookup':
        case 'LookupOrderedRows':
        case 'LookupOrderedRowsCS':
        case 'LookupRows':
        case 'LookupRowsCS':
        case 'DataExtensionRowCount':
        case 'DeleteData':
        case 'DeleteDE':
        case 'InsertDE':
        case 'UpdateData':
        case 'UpdateDE':
        case 'UpsertData':
        case 'UpsertDE':
        case 'ClaimRow':
            resp.matchedValue = matchedValue.split(',')[0].trim();
            resp.context = 'dataExtension';
            resp.payload =
                yield client.emailStudio.retrieveDataExtensionPayloadByName(resp.matchedValue);
            bldrId = yield (0, __1.guid)();
            resp.payload.bldrId = bldrId;
            resp.payload.assetType = {
                name: 'dataextension',
            };
            resp.bldrId = bldrId;
            break;
        case 'ContentBlockById':
        case 'ContentBlockByID':
        case 'ContentBlockbyID':
            resp.context = 'contentBuilder';
            // Do not capture existing Content Builder assets if they already exist in package
            assetExists = (_a = packageOut.contentBuilder) === null || _a === void 0 ? void 0 : _a.assets.find((asset) => Number(asset.id) === Number(matchedValue));
            // Do not capture existing Content Builder assets if they already exist in package
            if (assetExists) {
                assetExists.exists = true;
                assetExists.context = 'contentBuilder';
                return assetExists;
            }
            else {
                resp.payload = yield client.asset.getByAssetId(matchedValue);
                bldrId = yield (0, __1.guid)();
                resp.payload.bldrId = bldrId;
                resp.bldrId = bldrId;
            }
            break;
        case 'ContentBlockByName':
            contentBlockPathArray = matchedValue.split('\\').filter(Boolean);
            contentBlockName = contentBlockPathArray.pop();
            contentBlockFolder =
                contentBlockPathArray[contentBlockPathArray.length - 1];
            // Do not capture existing Content Builder assets if they already exist in package
            assetExists = (_b = packageOut.contentBuilder) === null || _b === void 0 ? void 0 : _b.assets.find((asset) => asset.name === contentBlockName);
            resp.context = 'contentBuilder';
            if (assetExists) {
                assetExists.exists = true;
                assetExists.context = 'contentBuilder';
                return assetExists;
            }
            else {
                const dependencyRequest = yield client.asset.getAssetByNameAndFolder({
                    assetName: contentBlockName,
                    assetFolderName: contentBlockFolder,
                });
                resp.payload = dependencyRequest;
            }
            bldrId = yield (0, __1.guid)();
            resp.payload.bldrId = bldrId;
            resp.bldrId = bldrId;
            break;
        default:
    }
    return resp;
});
exports.getAssetDependency = getAssetDependency;
const setUpdatedPackageAssetContent = (dependencyReference, matchedValue, assetContent) => {
    const { reference, bldrId } = dependencyReference;
    switch (reference) {
        case 'Lookup':
        case 'LookupOrderedRows':
        case 'LookupOrderedRowsCS':
        case 'LookupRows':
        case 'LookupRowsCS':
        case 'DataExtensionRowCount':
        case 'DeleteData':
        case 'DeleteDE':
        case 'InsertDE':
        case 'UpdateData':
        case 'UpdateDE':
        case 'UpsertData':
        case 'UpsertDE':
        case 'ClaimRow':
            assetContent = assetContent.replaceAll(matchedValue, bldrId);
            break;
        case 'ContentBlockById':
        case 'ContentBlockByID':
        case 'ContentBlockbyID':
            assetContent = assetContent.replaceAll(matchedValue, bldrId);
            break;
        case 'ContentBlockByName':
            assetContent = assetContent.replaceAll(matchedValue, bldrId);
            break;
        default:
    }
    return assetContent;
};
exports.setUpdatedPackageAssetContent = setUpdatedPackageAssetContent;
