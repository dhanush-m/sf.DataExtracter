"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Automation = void 0;
const automationActivities_1 = require("../utils/automationActivities");
const handleError_1 = require("../utils/handleError");
const { getProperties } = require('sfmc-soap-object-reference');
const automationDefinition = getProperties('Automation');
const emailSendDefinition = getProperties('EmailSendDefinition');
class Automation {
    constructor(client) {
        this.searchActivity = (searchActivity, searchTerm) => __awaiter(this, void 0, void 0, function* () {
            try {
                return this.client.rest.get(`/automation/v1/${searchActivity}?$filter=name='${searchTerm}'`);
            }
            catch (err) {
                return err;
            }
        });
        /**
         *
         * @param asset
         * @returns
         */
        this.postAsset = (asset) => __awaiter(this, void 0, void 0, function* () {
            try {
                const assetType = asset.assetType;
                const resp = yield this.client.rest.post(`/automation/v1/${assetType}`, asset);
                return resp;
            }
            catch (err) {
                return err;
            }
        });
        this.client = client;
    }
    /**
     * Search for Automations by SOAP API
     * @param {string} request.searchKey
     * @param {string} request.searchTerm
     * @returns
     */
    searchAutomations(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.client.soap.retrieveBulk('Program', automationDefinition, {
                    filter: {
                        leftOperand: request.searchKey,
                        operator: 'like',
                        rightOperand: request.searchTerm,
                    },
                });
            }
            catch (err) {
                return (0, handleError_1.handleError)(err);
            }
        });
    }
    /**
     * Search for Automation Studio Activity by Type and Name
     *
     * @param {string} request.searchActivity
     * @param {string} request.searchTerm
     * @returns
     */
    searchActivityByName(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.client.rest.get(`/automation/v1/${request.searchActivity}?$filter=name='${request.searchTerm}'`);
            }
            catch (err) {
                return (0, handleError_1.handleError)(err);
            }
        });
    }
    /**
     * Search for Automation Studio Activity by Type and Name
     *
     * @param {string} request.searchActivity
     * @param {string} request.searchTerm
     * @returns
     */
    searchActivityByCategoryId(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.client.rest.get(`/automation/v1/${request.searchActivity}/category/${request.categoryId}`);
            }
            catch (err) {
                return (0, handleError_1.handleError)(err);
            }
        });
    }
    /**
     * Retrieve multiple automations from array of categoryIds
     *
     * @param {number[]} categoryIds
     * @returns
     */
    getAssetsByFolderArray(categoryIds) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = [];
            if (!categoryIds || !Array.isArray(categoryIds)) {
                throw new Error('folderIds is required and must be an array');
            }
            for (const f in categoryIds) {
                const categoryId = categoryIds[f];
                const request = yield this.client.rest.get(`/legacy/v1/beta/automations/automation/definition/?$sort=lastRunTime desc&categoryId=${categoryId}`);
                if (Object.prototype.hasOwnProperty.call(request, 'entry')) {
                    result.push(...request.entry);
                }
            }
            return result;
        });
    }
    /**
     * Retrieve an automation by automation key
     *
     * @param {string} automationKey
     * @returns {Promise<void>}
     */
    getAutomationByKey(automationKey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.client.rest.get(`/automation/v1/automations/${automationKey}`);
            }
            catch (err) {
                return (0, handleError_1.handleError)(err);
            }
        });
    }
    /**
     * Retrieve multiple automations by automation keys array
     *
     * @param {string[]} automationKeys
     * @returns {Promise<void>}
     */
    getAutomationsByKey(automationKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = [];
                if (!Array.isArray(automationKeys)) {
                    throw new Error('automationKeys needs to be an array');
                }
                for (const a in automationKeys) {
                    const key = automationKeys[a];
                    const request = yield this.client.rest.get(`/automation/v1/automations/${key}`);
                    if (Object.prototype.hasOwnProperty.call(request, 'id')) {
                        result.push(request);
                    }
                }
                return result;
            }
            catch (err) {
                return (0, handleError_1.handleError)(err);
            }
        });
    }
    /**
     * Retrieve automation activity details
     *
     * @param request.assetType
     * @param request.activityObjectId
     * @returns
     */
    getAutomationActivity(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.client.rest.get(`/automation/v1/${request.activityType}/${request.activityObjectId}`);
                return resp;
            }
            catch (err) {
                return err;
            }
        });
    }
    /**
     *
     * @param automation {object}
     * @returns
     */
    getAutomationActivities(automation) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const activityDefinitions = [];
                if (Object.prototype.hasOwnProperty.call(automation, 'steps')) {
                    for (const as in automation.steps) {
                        const steps = automation.steps[as];
                        for (const sa in steps.activities) {
                            const activity = steps.activities[sa];
                            const assetType = (0, automationActivities_1.MappingByActivityTypeId)(activity.objectTypeId);
                            if (assetType) {
                                // Most activities can be pulled from the automations endpoint
                                const activityObjectId = activity.activityObjectId;
                                let stepActivity;
                                const objectIdKey = (assetType &&
                                    assetType.objectIdKey &&
                                    typeof assetType.objectIdKey === 'string' &&
                                    assetType.objectIdKey) ||
                                    'id';
                                // EmailSendDefinitions are not on the automations REST endpoint
                                if (assetType.name === 'userinitiatedsend') {
                                    stepActivity =
                                        yield this.getEmailSendDefinitionActivity(activityObjectId);
                                    if (stepActivity && !stepActivity.CustomerKey) {
                                        stepActivity = Object.assign(Object.assign({}, steps.activities[sa]), { [objectIdKey]: activityObjectId, hasBeenDeleted: true });
                                    }
                                }
                                else if (assetType.name === 'filteractivity') {
                                    stepActivity =
                                        yield this.retrieveAutomationActivityDefinition(assetType, activityObjectId);
                                    if (stepActivity) {
                                        const activityDefinitionId = stepActivity.filterDefinitionId;
                                        const filterDefinition = yield this.retrieveFilterDefinition(activityDefinitionId);
                                        if (filterDefinition) {
                                            stepActivity.filterDefinition =
                                                filterDefinition;
                                        }
                                        else {
                                            stepActivity.filterDefinition = Object.assign(Object.assign({}, steps.activities[sa]), { filterDefinitionId: activityDefinitionId, hasBeenDeleted: true });
                                        }
                                    }
                                    else {
                                        stepActivity = Object.assign(Object.assign({}, steps.activities[sa]), { [objectIdKey]: activityObjectId, hasBeenDeleted: true });
                                    }
                                }
                                else {
                                    stepActivity = yield this.client.rest.get(`/automation/v1/${assetType.api}/${activityObjectId}`);
                                    const activityResponseKeys = Object.keys(stepActivity);
                                    if (stepActivity &&
                                        !activityResponseKeys.some((key) => [
                                            'key',
                                            'customerKey',
                                            'CustomerKey',
                                        ].includes(key))) {
                                        stepActivity = Object.assign(Object.assign({}, steps.activities[sa]), { [objectIdKey]: activityObjectId, hasBeenDeleted: true });
                                    }
                                }
                                stepActivity.assetType = assetType;
                                stepActivity.category = {
                                    folderPath: assetType.folder,
                                };
                                activityDefinitions.push(stepActivity);
                            }
                        }
                    }
                }
                return activityDefinitions;
            }
            catch (err) {
                return err;
            }
        });
    }
    retrieveAutomationActivityDefinition(assetType, activityObjectId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stepActivity = yield this.client.rest.get(`/automation/v1/${assetType.api}/${activityObjectId}`);
                return stepActivity;
            }
            catch (err) {
                return null;
            }
        });
    }
    retrieveFilterDefinition(activityDefinitionId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.client.rest.get(`/email/v1/filters/filterdefinition/${activityDefinitionId}`);
            }
            catch (err) {
                return null;
            }
        });
    }
    /**
     * Retrieve Email Send Definition
     *
     * @param {string} activityObjectId
     * @returns
     */
    getEmailSendDefinitionActivity(activityObjectId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const activityResponse = yield this.client.soap.retrieve('EmailSendDefinition', [...emailSendDefinition], {
                    filter: {
                        leftOperand: 'ObjectID',
                        operator: 'equals',
                        rightOperand: activityObjectId,
                    },
                });
                if (activityResponse.OverallStatus !== 'OK' ||
                    activityResponse.Results.length === 0) {
                    throw new Error(activityResponse.OverallStatus);
                }
                const result = activityResponse.Results[0];
                return {
                    ObjectID: result.ObjectID,
                    CustomerKey: result.CustomerKey,
                    Name: result.Name,
                    Description: result.Description,
                    CategoryID: result.CategoryID,
                    SendClassification: {
                        CustomerKey: result.SendClassification.CustomerKey,
                    },
                    SuppressTracking: result.SuppressTracking,
                    IsSendLogging: result.IsSendLogging,
                    SendDefinitionList: result.SendDefinitionList,
                    Email: {
                        ID: result.Email.ID,
                    },
                    BccEmail: result.BccEmail,
                    AutoBccEmail: result.AutoBccEmail,
                    TestEmailAddr: result.TestEmailAddr,
                    EmailSubject: result.EmailSubject,
                    DynamicEmailSubject: result.DynamicEmailSubject,
                    IsMultipart: result.IsMultipart,
                    IsWrapped: result.IsWrapped,
                    DeduplicateByEmail: result.DeduplicateByEmail,
                    ExclusionFilter: result.ExclusionFilter,
                    Additional: result.Additional,
                    CCEmail: result.CCEmail,
                };
            }
            catch (err) {
                return err;
            }
        });
    }
    /**
     *
     * @param asset
     * @returns
     */
    patchAutomationAsset(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const assetType = asset.assetType;
                const objectKey = assetType.objectIdKey;
                const assetObjectId = asset && asset[objectKey];
                const resp = yield this.client.rest.patch(`/automation/v1/${assetType.api}/${assetObjectId}`, asset);
                return resp;
            }
            catch (err) {
                return err;
            }
        });
    }
}
exports.Automation = Automation;
